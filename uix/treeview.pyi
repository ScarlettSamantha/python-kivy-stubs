"""
This type stub file was generated by pyright.
"""

from kivy.uix.label import Label
from kivy.uix.widget import Widget
from kivy.app import App

'''
Tree View
=========

.. image:: images/treeview.png
    :align: right

.. versionadded:: 1.0.4


:class:`TreeView` is a widget used to represent a tree structure. It is
currently very basic, supporting a minimal feature set.

Introduction
------------

A :class:`TreeView` is populated with :class:`TreeViewNode` instances, but you
cannot use a :class:`TreeViewNode` directly. You must combine it with another
widget, such as :class:`~kivy.uix.label.Label`,
:class:`~kivy.uix.button.Button` or even your own widget. The TreeView
always creates a default root node, based on :class:`TreeViewLabel`.

:class:`TreeViewNode` is a class object containing needed properties for
serving as a tree node. Extend :class:`TreeViewNode` to create custom node
types for use with a :class:`TreeView`.

For constructing your own subclass, follow the pattern of TreeViewLabel which
combines a Label and a TreeViewNode, producing a :class:`TreeViewLabel` for
direct use in a TreeView instance.

To use the TreeViewLabel class, you could create two nodes directly attached
to root::

    tv = TreeView()
    tv.add_node(TreeViewLabel(text='My first item'))
    tv.add_node(TreeViewLabel(text='My second item'))

Or, create two nodes attached to a first::

    tv = TreeView()
    n1 = tv.add_node(TreeViewLabel(text='Item 1'))
    tv.add_node(TreeViewLabel(text='SubItem 1'), n1)
    tv.add_node(TreeViewLabel(text='SubItem 2'), n1)

If you have a large tree structure, perhaps you would need a utility function
to populate the tree view::

    def populate_tree_view(tree_view, parent, node):
        if parent is None:
            tree_node = tree_view.add_node(TreeViewLabel(text=node['node_id'],
                                                         is_open=True))
        else:
            tree_node = tree_view.add_node(TreeViewLabel(text=node['node_id'],
                                                         is_open=True), parent)

        for child_node in node['children']:
            populate_tree_view(tree_view, tree_node, child_node)


    tree = {'node_id': '1',
            'children': [{'node_id': '1.1',
                          'children': [{'node_id': '1.1.1',
                                        'children': [{'node_id': '1.1.1.1',
                                                      'children': []}]},
                                       {'node_id': '1.1.2',
                                        'children': []},
                                       {'node_id': '1.1.3',
                                        'children': []}]},
                          {'node_id': '1.2',
                           'children': []}]}


    class TreeWidget(FloatLayout):
        def __init__(self, **kwargs):
            super(TreeWidget, self).__init__(**kwargs)

            tv = TreeView(root_options=dict(text='Tree One'),
                          hide_root=False,
                          indent_level=4)

            populate_tree_view(tv, None, tree)

            self.add_widget(tv)

The root widget in the tree view is opened by default and has text set as
'Root'. If you want to change that, you can use the
:attr:`TreeView.root_options`
property. This will pass options to the root widget::

    tv = TreeView(root_options=dict(text='My root label'))


Creating Your Own Node Widget
-----------------------------

For a button node type, combine a :class:`~kivy.uix.button.Button` and a
:class:`TreeViewNode` as follows::

    class TreeViewButton(Button, TreeViewNode):
        pass

You must know that, for a given node, only the
:attr:`~kivy.uix.widget.Widget.size_hint_x` will be honored. The allocated
width for the node will depend of the current width of the TreeView and the
level of the node. For example, if a node is at level 4, the width
allocated will be:

    treeview.width - treeview.indent_start - treeview.indent_level * node.level

You might have some trouble with that. It is the developer's responsibility to
correctly handle adapting the graphical representation nodes, if needed.
'''
class TreeViewException(Exception):
    '''Exception for errors in the :class:`TreeView`.
    '''
    ...


class TreeViewNode:
    '''TreeViewNode class, used to build a node class for a TreeView object.
    '''
    def __init__(self, **kwargs) -> None:
        ...
    
    is_leaf = ...
    is_open = ...
    is_loaded = ...
    is_selected = ...
    no_selection = ...
    nodes = ...
    parent_node = ...
    level = ...
    color_selected = ...
    odd = ...
    odd_color = ...
    even_color = ...


class TreeViewLabel(Label, TreeViewNode):
    '''Combines a :class:`~kivy.uix.label.Label` and a :class:`TreeViewNode` to
    create a :class:`TreeViewLabel` that can be used as a text node in the
    tree.

    See module documentation for more information.
    '''
    ...


class TreeView(Widget):
    '''TreeView class. See module documentation for more information.

    :Events:
        `on_node_expand`: (node, )
            Fired when a node is being expanded
        `on_node_collapse`: (node, )
            Fired when a node is being collapsed
    '''
    __events__ = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def add_node(self, node, parent=...): # -> TreeViewNode:
        '''Add a new node to the tree.

        :Parameters:
            `node`: instance of a :class:`TreeViewNode`
                Node to add into the tree
            `parent`: instance of a :class:`TreeViewNode`, defaults to None
                Parent node to attach the new node. If `None`, it is added to
                the :attr:`root` node.

        :returns:
            the node `node`.
        '''
        ...
    
    def remove_node(self, node): # -> None:
        '''Removes a node from the tree.

        .. versionadded:: 1.0.7

        :Parameters:
            `node`: instance of a :class:`TreeViewNode`
                Node to remove from the tree. If `node` is :attr:`root`, it is
                not removed.
        '''
        ...
    
    def on_node_expand(self, node): # -> None:
        ...
    
    def on_node_collapse(self, node): # -> None:
        ...
    
    def select_node(self, node): # -> None:
        '''Select a node in the tree.
        '''
        ...
    
    def deselect_node(self, *args): # -> None:
        '''Deselect any selected node.

        .. versionadded:: 1.10.0
        '''
        ...
    
    def toggle_node(self, node): # -> None:
        '''Toggle the state of the node (open/collapsed).
        '''
        ...
    
    def get_node_at_pos(self, pos): # -> None:
        '''Get the node at the position (x, y).
        '''
        ...
    
    def iterate_open_nodes(self, node=...): # -> Generator[Any, Any, None]:
        '''Generator to iterate over all the expended nodes starting from
        `node` and down. If `node` is `None`, the generator start with
        :attr:`root`.

        To get all the open nodes::

            treeview = TreeView()
            # ... add nodes ...
            for node in treeview.iterate_open_nodes():
                print(node)

        '''
        ...
    
    def iterate_all_nodes(self, node=...): # -> Generator[Any | TreeViewNode, Any, None]:
        '''Generator to iterate over all nodes from `node` and down whether
        expanded or not. If `node` is `None`, the generator start with
        :attr:`root`.
        '''
        ...
    
    def on_load_func(self, instance, value): # -> None:
        ...
    
    def on_root_options(self, instance, value): # -> None:
        ...
    
    def on_touch_down(self, touch): # -> Literal[True] | None:
        ...
    
    _root = ...
    _selected_node = ...
    minimum_width = ...
    minimum_height = ...
    minimum_size = ...
    indent_level = ...
    indent_start = ...
    hide_root = ...
    def get_selected_node(self): # -> None:
        ...
    
    selected_node = ...
    def get_root(self): # -> TreeViewNode:
        ...
    
    root = ...
    root_options = ...
    load_func = ...


if __name__ == '__main__':
    class TestApp(App):
        def build(self): # -> TreeView:
            ...
        
    
    
