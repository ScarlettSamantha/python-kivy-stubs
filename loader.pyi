"""
This type stub file was generated by pyright.
"""

from kivy.core.image import Image
from os import environ
from threading import Thread

'''
Asynchronous data loader
========================

This is the Asynchronous Loader. You can use it to load an image
and use it, even if data are not yet available. You must specify a default
loading image when using the loader::

    from kivy.loader import Loader
    image = Loader.image('mysprite.png')

You can also load an image from a url::

    image = Loader.image('http://mysite.com/test.png')

If you want to change the default loading image, you can do::

    Loader.loading_image = Image('another_loading.png')

Tweaking the asynchronous loader
--------------------------------

.. versionadded:: 1.6.0

You can tweak the loader to provide a better user experience or more
performance, depending of the images you are going to load. Take a look at the
parameters:

- :attr:`Loader.num_workers` - define the number of threads to start for
  loading images.
- :attr:`Loader.max_upload_per_frame` - define the maximum image uploads in
  GPU to do per frame.

'''
__all__ = ('Loader', 'LoaderBase', 'ProxyImage')
class ProxyImage(Image):
    '''Image returned by the Loader.image() function.

    :Properties:
        `loaded`: bool, defaults to False
            This value may be True if the image is already cached.

    :Events:
        `on_load`
            Fired when the image is loaded or changed.
        `on_error`
            Fired when the image cannot be loaded.
            `error`: Exception data that occurred
    '''
    __events__ = ...
    def __init__(self, arg, **kwargs) -> None:
        ...
    
    def on_load(self): # -> None:
        ...
    
    def on_error(self, error): # -> None:
        ...
    


class LoaderBase:
    '''Common base for the Loader and specific implementations.
    By default, the Loader will be the best available loader implementation.

    The _update() function is called every 1 / 25.s or each frame if we have
    less than 25 FPS.
    '''
    _trigger_update = ...
    EXT_ALIAS = ...
    def __init__(self) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    num_workers = ...
    max_upload_per_frame = ...
    loading_image = ...
    error_image = ...
    def start(self): # -> None:
        '''Start the loader thread/process.'''
        ...
    
    def run(self, *largs): # -> None:
        '''Main loop for the loader.'''
        ...
    
    def stop(self): # -> None:
        '''Stop the loader thread/process.'''
        ...
    
    def pause(self): # -> None:
        '''Pause the loader, can be useful during interactions.

        .. versionadded:: 1.6.0
        '''
        ...
    
    def resume(self): # -> None:
        '''Resume the loader, after a :meth:`pause`.

        .. versionadded:: 1.6.0
        '''
        ...
    
    def image(self, filename, load_callback=..., post_callback=..., **kwargs): # -> ProxyImage:
        '''Load a image using the Loader. A ProxyImage is returned with a
        loading image. You can use it as follows::

            from kivy.app import App
            from kivy.uix.image import Image
            from kivy.loader import Loader

            class TestApp(App):
                def _image_loaded(self, proxyImage):
                    if proxyImage.image.texture:
                        self.image.texture = proxyImage.image.texture

                def build(self):
                    proxyImage = Loader.image("myPic.jpg")
                    proxyImage.bind(on_load=self._image_loaded)
                    self.image = Image()
                    return self.image

            TestApp().run()

        In order to cancel all background loading, call *Loader.stop()*.
        '''
        ...
    
    def remove_from_cache(self, filename): # -> None:
        ...
    


if 'KIVY_DOC' in environ:
    Loader = ...
else:
    class _Worker(Thread):
        '''Thread executing tasks from a given tasks queue
        '''
        def __init__(self, pool, tasks) -> None:
            ...
        
        def run(self): # -> None:
            ...
        
    
    
    class _ThreadPool:
        '''Pool of threads consuming tasks from a queue
        '''
        def __init__(self, num_threads) -> None:
            ...
        
        def add_task(self, func, *args, **kargs): # -> None:
            '''Add a task to the queue
            '''
            ...
        
        def stop(self): # -> None:
            ...
        
    
    
    class LoaderThreadPool(LoaderBase):
        def __init__(self) -> None:
            ...
        
        def start(self): # -> None:
            ...
        
        def stop(self): # -> None:
            ...
        
        def run(self, *largs): # -> None:
            ...
        
    
    
    Loader = ...
