"""
This type stub file was generated by pyright.
"""

from kivy.input.provider import MotionEventProvider
from kivy.input.motionevent import MotionEvent

'''
Mouse provider implementation
=============================

On linux systems, the mouse provider can be annoying when used with another
multitouch provider (hidinput or mtdev). The Mouse can conflict with them: a
single touch can generate one event from the mouse provider and another
from the multitouch provider.

To avoid this behavior, you can activate the "disable_on_activity" token in
the mouse configuration. Then, if any touches are created by another
provider, the mouse event will be discarded. Add this to your configuration::

    [input]
    mouse = mouse,disable_on_activity

Using multitouch interaction with the mouse
-------------------------------------------

.. versionadded:: 1.3.0

By default, the middle and right mouse buttons, as well as a combination of
ctrl + left mouse button are used for multitouch emulation.
If you want to use them for other purposes, you can disable this behavior by
activating the "disable_multitouch" token::

   [input]
   mouse = mouse,disable_multitouch

.. versionchanged:: 1.9.0

You can now selectively control whether a click initiated as described above
will emulate multi-touch. If the touch has been initiated in the above manner
(e.g. right mouse button), a `multitouch_sim` value will be added to the
touch's profile, and a `multitouch_sim` property will be added to the touch.
By default, `multitouch_sim` is True and multitouch will be emulated for that
touch. If, however, `multitouch_on_demand` is added to the config::

   [input]
   mouse = mouse,multitouch_on_demand

then `multitouch_sim` defaults to `False`. In that case, if `multitouch_sim`
is set to True before the mouse is released (e.g. in on_touch_down/move), the
touch will simulate a multi-touch event. For example::

    if 'multitouch_sim' in touch.profile:
        touch.multitouch_sim = True

.. versionchanged:: 2.1.0

Provider dispatches hover events by listening to properties/events in
:class:`~kivy.core.window.Window`. Dispatching can be disabled by setting
:attr:`MouseMotionEventProvider.disable_hover` to ``True`` or by adding
`disable_hover` in the config::

    [input]
    mouse = mouse,disable_hover

It's also possible to enable/disable hover events at runtime with
:attr:`MouseMotionEventProvider.disable_hover` property.

Following is a list of the supported values for the
:attr:`~kivy.input.motionevent.MotionEvent.profile` property list.

================ ==========================================================
Profile value    Description
---------------- ----------------------------------------------------------
button           Mouse button (one of `left`, `right`, `middle`, `scrollup`
                 or `scrolldown`). Accessed via the 'button' property.
pos              2D position. Also reflected in the
                 :attr:`~kivy.input.motionevent.MotionEvent.x`,
                 :attr:`~kivy.input.motionevent.MotionEvent.y`
                 and :attr:`~kivy.input.motionevent.MotionEvent.pos`
                 properties.
multitouch_sim   Specifies whether multitouch is simulated or not. Accessed
                 via the 'multitouch_sim' property.
================ ==========================================================

'''
__all__ = ('MouseMotionEventProvider', )
Ellipse = ...
class MouseMotionEvent(MotionEvent):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def depack(self, args): # -> None:
        ...
    
    def update_graphics(self, win, create=...): # -> None:
        ...
    
    def clear_graphics(self, win): # -> None:
        ...
    


class MouseMotionEventProvider(MotionEventProvider):
    __handlers__ = ...
    def __init__(self, device, args) -> None:
        ...
    
    disable_hover = ...
    def start(self): # -> None:
        '''Start the mouse provider'''
        ...
    
    def stop(self): # -> None:
        '''Stop the mouse provider'''
        ...
    
    def test_activity(self): # -> bool:
        ...
    
    def find_touch(self, win, x, y): # -> None:
        ...
    
    def create_event_id(self):
        ...
    
    def create_touch(self, win, nx, ny, is_double_tap, do_graphics, button): # -> MouseMotionEvent:
        ...
    
    def remove_touch(self, win, touch): # -> None:
        ...
    
    def create_hover(self, win, etype): # -> None:
        ...
    
    def on_mouse_motion(self, win, x, y, modifiers): # -> None:
        ...
    
    def on_mouse_press(self, win, x, y, button, modifiers): # -> None:
        ...
    
    def on_mouse_release(self, win, x, y, button, modifiers): # -> None:
        ...
    
    def update_touch_graphics(self, win, *args): # -> None:
        ...
    
    def begin_or_update_hover_event(self, win, *args): # -> None:
        ...
    
    def begin_hover_event(self, win, *args): # -> None:
        ...
    
    def update_hover_event(self, win, *args): # -> None:
        ...
    
    def end_hover_event(self, win, *args): # -> None:
        ...
    
    def update(self, dispatch_fn): # -> None:
        '''Update the mouse provider (pop event from the queue)'''
        ...
    


