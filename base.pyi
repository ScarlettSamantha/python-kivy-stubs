"""
This type stub file was generated by pyright.
"""

from kivy.event import EventDispatcher

'''
Kivy Base
=========

This module contains the Kivy core functionality and is not intended for end
users. Feel free to look through it, but bare in mind that calling any of
these methods directly may result in an unpredictable behavior as the calls
access directly the event loop of an application.
'''
__all__ = ('EventLoop', 'EventLoopBase', 'ExceptionHandler', 'ExceptionManagerBase', 'ExceptionManager', 'runTouchApp', 'async_runTouchApp', 'stopTouchApp')
EventLoop = ...
class ExceptionHandler:
    '''Base handler that catches exceptions in :func:`runTouchApp`.
    You can subclass and extend it as follows::

        class E(ExceptionHandler):
            def handle_exception(self, inst):
                Logger.exception('Exception caught by ExceptionHandler')
                return ExceptionManager.PASS

        ExceptionManager.add_handler(E())

    Then, all exceptions will be set to PASS, and logged to the console!
    '''
    def handle_exception(self, exception): # -> Literal[0]:
        '''Called by :class:`ExceptionManagerBase` to handle a exception.

        Defaults to returning :attr:`ExceptionManager.RAISE` that re-raises the
        exception. Return :attr:`ExceptionManager.PASS` to indicate that the
        exception was handled and should be ignored.

        This may be called multiple times with the same exception, if
        :attr:`ExceptionManager.RAISE` is returned as the exception bubbles
        through multiple kivy exception handling levels.
        '''
        ...
    


class ExceptionManagerBase:
    '''ExceptionManager manages exceptions handlers.'''
    RAISE = ...
    PASS = ...
    def __init__(self) -> None:
        ...
    
    def add_handler(self, cls): # -> None:
        '''Add a new exception handler to the stack.'''
        ...
    
    def remove_handler(self, cls): # -> None:
        '''Remove the exception handler from the stack.'''
        ...
    
    def handle_exception(self, inst): # -> int:
        '''Called when an exception occurred in the :func:`runTouchApp`
        main loop.'''
        ...
    


ExceptionManager: ExceptionManagerBase = ...
class EventLoopBase(EventDispatcher):
    '''Main event loop. This loop handles the updating of input and
    dispatching events.
    '''
    __events__ = ...
    def __init__(self) -> None:
        ...
    
    @property
    def touches(self): # -> list[Any]:
        '''Return the list of all touches currently in down or move states.
        '''
        ...
    
    def ensure_window(self): # -> None:
        '''Ensure that we have a window.
        '''
        ...
    
    def set_window(self, window): # -> None:
        '''Set the window used for the event loop.
        '''
        ...
    
    def add_input_provider(self, provider, auto_remove=...): # -> None:
        '''Add a new input provider to listen for touch events.
        '''
        ...
    
    def remove_input_provider(self, provider): # -> None:
        '''Remove an input provider.

        .. versionchanged:: 2.1.0
            Provider will be also removed if it exist in auto-remove list.
        '''
        ...
    
    def add_event_listener(self, listener): # -> None:
        '''Add a new event listener for getting touch events.
        '''
        ...
    
    def remove_event_listener(self, listener): # -> None:
        '''Remove an event listener from the list.
        '''
        ...
    
    def start(self): # -> None:
        '''Must be called before :meth:`EventLoopBase.run()`. This starts all
        configured input providers.

        .. versionchanged:: 2.1.0
            Method can be called multiple times, but event loop will start only
            once.
        '''
        ...
    
    def close(self): # -> None:
        '''Exit from the main loop and stop all configured
        input providers.'''
        ...
    
    def stop(self): # -> None:
        '''Stop all input providers and call callbacks registered using
        `EventLoop.add_stop_callback()`.

        .. versionchanged:: 2.1.0
            Method can be called multiple times, but event loop will stop only
            once.
        '''
        ...
    
    def add_postproc_module(self, mod): # -> None:
        '''Add a postproc input module (DoubleTap, TripleTap, DeJitter
        RetainTouch are defaults).'''
        ...
    
    def remove_postproc_module(self, mod): # -> None:
        '''Remove a postproc module.'''
        ...
    
    def remove_android_splash(self, *args): # -> None:
        '''Remove android presplash in SDL2 bootstrap.'''
        ...
    
    def post_dispatch_input(self, etype, me): # -> None:
        '''This function is called by :meth:`EventLoopBase.dispatch_input()`
        when we want to dispatch an input event. The event is dispatched to
        all listeners and if grabbed, it's dispatched to grabbed widgets.
        '''
        ...
    
    def dispatch_input(self): # -> None:
        '''Called by :meth:`EventLoopBase.idle()` to read events from input
        providers, pass events to postproc, and dispatch final events.
        '''
        ...
    
    def mainloop(self): # -> None:
        ...
    
    async def async_mainloop(self): # -> None:
        ...
    
    def idle(self): # -> bool:
        '''This function is called after every frame. By default:

           * it "ticks" the clock to the next frame.
           * it reads all input and dispatches events.
           * it dispatches `on_update`, `on_draw` and `on_flip` events to the
             window.
        '''
        ...
    
    async def async_idle(self): # -> bool:
        '''Identical to :meth:`idle`, but instead used when running
        within an async event loop.
        '''
        ...
    
    def run(self): # -> None:
        '''Main loop'''
        ...
    
    def exit(self): # -> None:
        '''Close the main loop and close the window.'''
        ...
    
    def on_stop(self): # -> None:
        '''Event handler for `on_stop` events which will be fired right
        after all input providers have been stopped.'''
        ...
    
    def on_pause(self): # -> None:
        '''Event handler for `on_pause` which will be fired when
        the event loop is paused.'''
        ...
    
    def on_start(self): # -> None:
        '''Event handler for `on_start` which will be fired right
        after all input providers have been started.'''
        ...
    


EventLoop = ...
def runTouchApp(widget=..., embedded=...): # -> None:
    '''Static main function that starts the application loop.
    You can access some magic via the following arguments:

    See :mod:`kivy.app` for example usage.

    :Parameters:
        `<empty>`
            To make dispatching work, you need at least one
            input listener. If not, application will leave.
            (MTWindow act as an input listener)

        `widget`
            If you pass only a widget, a MTWindow will be created
            and your widget will be added to the window as the root
            widget.

        `embedded`
            No event dispatching is done. This will be your job.

        `widget + embedded`
            No event dispatching is done. This will be your job but
            we try to get the window (must be created by you beforehand)
            and add the widget to it. Very useful for embedding Kivy
            in another toolkit. (like Qt, check kivy-designed)

    '''
    ...

async def async_runTouchApp(widget=..., embedded=..., async_lib=...): # -> None:
    '''Identical to :func:`runTouchApp` but instead it is a coroutine
    that can be run in an existing async event loop.

    ``async_lib`` is the async library to use. See :mod:`kivy.app` for details
    and example usage.

    .. versionadded:: 2.0.0
    '''
    ...

def stopTouchApp(): # -> None:
    '''Stop the current application by leaving the main loop.

    See :mod:`kivy.app` for example usage.
    '''
    ...

